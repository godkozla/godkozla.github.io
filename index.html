<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
  <title>.lottie responsive (intrinsic ratio)</title>
  <style>
    :root { --bg: #fff; } /* фон страницы при желании меняй */

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
    }
    .viewport {
      min-height: 100dvh;
      width: 100%;
      display: flex;
      align-items: center;      /* центр по вертикали */
      justify-content: center;  /* центр по горизонтали */
      overflow: hidden;
      touch-action: manipulation; /* не блокируй жесты */
    }
    /* Размеры .lottie-box задаём из JS, чтобы точно вписать по экрану */
    .lottie-box { position: relative; }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <div class="viewport">
    <div class="lottie-box" id="box">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <script type="module">
    import { DotLottie } from "https://cdn.jsdelivr.net/npm/@lottiefiles/dotlottie-web/+esm";

    const box = document.getElementById('box');
    const canvas = document.getElementById('canvas');

    // Инициализация плеера
    const player = new DotLottie({
      canvas,
      src: "./animation.lottie",
      autoplay: true,
      loop: true,
      renderer: "canvas" // можно "svg" при необходимости
    });

    // Текущее соотношение сторон (по умолчанию 1:1, пока не узнаем истинное)
    let ratio = 1;

    // Пытаемся получить исходные w/h из анимации
    async function updateIntrinsicRatio() {
      try {
        const data = await player.getAnimationData?.(); // у dotlottie-web это лотти-JSON
        if (data?.w && data?.h) {
          ratio = data.w / data.h;
        }
      } catch (_) {
        // нет метода или нет данных — оставим ratio=1
      }
    }

    // Вписывание: сначала по ширине, если не помещается — по высоте
    function layout() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      // по ширине
      const hByWidth = vw / ratio;
      let drawW, drawH;
      if (hByWidth <= vh) {
        drawW = vw;
        drawH = hByWidth;
      } else {
        // иначе по высоте
        drawH = vh;
        drawW = vh * ratio;
      }

      // CSS-размер контейнера (в CSS-пикселях)
      box.style.width = `${Math.round(drawW)}px`;
      box.style.height = `${Math.round(drawH)}px`;

      // Реальный размер канваса (в device-pixels), чтобы не было блюра
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.max(1, Math.round(drawW * dpr));
      canvas.height = Math.max(1, Math.round(drawH * dpr));
    }

    // Обновляем при изменении экрана/ориентации
    window.addEventListener('resize', layout);
    window.addEventListener('orientationchange', layout);

    // Последовательность: узнаём ratio → раскладываем
    (async () => {
      await updateIntrinsicRatio();
      layout();
    })();

    // Дополнительно перелагаем при готовности анимации (на всякий случай)
    player.addEventListener('ready', layout);
  </script>
</body>
</html>
